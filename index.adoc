= Projetos - Processamento Digital de Imagens
José Lenildo Fernandes Dantas Júnior <lenildo.ze@gmail.com>
:toc: left
:toc-title: Sumário
:stem: latexmath

== Projetos da Primeira Unidade

:sectnums:

== Manipulação de Pixels

:sectnums:

=== Negativo de uma região

Este exercício tem como finalidade manipular uma determinada imagem de forma que, após receber duas coordeandas (x,y) que representam, respectivamente, o ponto inicial e final da área desejada, forme um retângulo onde será aplicado o negativo da imagem.


.Área criada com os pontos
image::/image/Retangulo.png[]


O conceito e negativo de uma imagem está atrelado ao fato de acessar os pixels da imagem e subtrair dele o valor máximo que ele pode assunmir. No caso deste exercício, estaremos utilizando uma imagem em tons de cinza com armazenamento de 1 byte, ou seja, cada pixel pode assumir valores entre 0 e 255. Com isso o negativo da imagem pode ser definido como

[source,cpp]
----
image.at<uchar>(i,j)=255-image.at<uchar>(i,j);
----

onde:

* *_image_* : Refere-se a imagem manipulada
* *_.at<uchar>_* : Método para acesso aos pixels de um _unsigned char_ (<uchar>) com 1 _byte_ de tamanho
* *_(i,j)_* : Representam as coordenadas (x,y) do pixel 

Para aplicar este efeito em toda a imagem, basta acrescentá-la a um laço _for()_ como mostra o trecho do código

[source,cpp]
----
for(int i=p1x;i<p2x;i++){
    for(int j=p1y;j<p2y;j++){
      image.at<uchar>(i,j)=255-image.at<uchar>(i,j);
    }
  }
----

O resultado da execução do programa link:/source_codes/regions.cpp[regions.cpp] pode ser visto abaixo

.Imagem utilizada na execução do programa
image::/image/biel.png[]

.Pontos informados pelo usuário
image::/image/execucaoRegions.png[]

.Imagem gerada na saída
image::/image/bielnegativo.png[]


=== Troca de Regiões

Este exercício tem como finalidade colocar em prática o conceito inicial de *_regiões_de_interesse(roi)_*, tornando possível criar um programa capaz de realizar a troca dos quadrantes de uma imagem. Neste exemplo, serão criadas 4 regiões de interesse de forma que, ao final do programa possa ser realizada a troca de cada região pela sua diagonal.

.Divisão das regiões da imagem
image::/image/regioesnomeadas.png[]

Inicialmente, realiza-se a leitura de uma imagem a ser processada pelo programa em duas variáveis do tipo *_Mat_* distintas, de forma que na primeira serão definidas as regiões de interesse que serão copiadas para a segunda.

[source,cpp]
----
 image= imread("biel.png",CV_LOAD_IMAGE_GRAYSCALE);
 newImage= imread("biel.png",CV_LOAD_IMAGE_GRAYSCALE);
----

_Obs: Como a variável *newImage* é igual a *image* também é possível criar uma cópia com a função *clone()*, pois o importante é obtermos uma matriz de dimensões equivalentes a da imagem original para a cópia das regiões_

As regiões de interesse foram definidas utilizando um construtor específico da https://docs.opencv.org/3.1.0/d3/d63/classcv_1_1Mat.html[Classe Mat]

[source,cpp]
----
 Mat (const Mat &m, const Rect &roi)
----

que possui como parâmetros, respectivamente, um objeto da classe _Mat_ e um objeto da classe _Rect_, sendo este último o responsável por informar a região de interesse da imagem _m_.

O primeiro passo é criar quatro objetos da classe _Rect_, referentes as quatro regiões de interesse da imagem, passando como parâmetros as duas coordenadas _x_ e _y_ que delimitarão a área desejada.

.Criação da área desejada para a Região de interesse
[source,cpp]
----
 Rect regA(0,0,image.cols/2,image.rows/2);
 Rect regB(image.cols/2,0,image.cols,image.rows/2);
 Rect regC(0,image.rows/2,image.cols/2,image.rows);
 Rect regD(image.cols/2,image.rows/2,image.cols,image.rows);
----

O segundo passo instintivo seria criar os objetos da classe _Mat_ correspondentes as _roi_. Entretanto ao se executar tal processo a seguinte mensagem de erro será exibida

.Erro exibido pelo console
image::/image/erroMat.png[]

referindo-se que a área de interesse está fora dos limites da imagem.

Para resolver este problema, deve-se executar os seguintes comandos

.Ajuste de dimensionalidade
[source,cpp]
----
	regA = regA & Rect(0,0,image.cols,image.rows);
	regB = regB & Rect(0,0,image.cols,image.rows);
	regC = regC & Rect(0,0,image.cols,image.rows);
	regD = regD & Rect(0,0,image.cols,image.rows);
----

que fará com que os retângulos criados sejam ajustados para atender as dimensões da imagem a qual deseja-se extrair as _roi_.

Após realizar os ajustes, procede-se a criação das regiões de interesse em definitivo, utilizando o contrutor da classe _Mat_ como mostra trecho de codigo 

.Criação das Regiões de Interesse
[source,cpp]
----
  Mat roiA(image,regA);
	Mat roiB(image,regB);
	Mat roiC(image,regC);
	Mat roiD(image,regD);
----

O próximo passo é realizar a troca entre os quadrantes da imagem. Para isso, utiliza-se novamente objetos da classe _Rect_ para definir a localização das _roi_ na imagem de destino.
_Obs:Este passo é opcional, considerando que o objeto pode ser passado diretamente no construtor da classe _Mat_, tratando-se apenas de uma melhor organização.

.Definição das regiões de destino
[source,cpp]
----
  Rect whereRecA(image.cols/2,image.rows/2,image.cols,image.rows); // <1>
	Rect whereRecB(0,image.rows/2,image.cols/2,image.rows);
	Rect whereRecC(image.cols/2,0,image.cols,image.rows/2);
	Rect whereRecD(0,0,image.cols/2,image.rows/2);

	whereRecA = whereRecA & Rect(0,0,image.cols,image.rows); // <2>
	whereRecB = whereRecB & Rect(0,0,image.cols,image.rows);
	whereRecC = whereRecC & Rect(0,0,image.cols,image.rows);
	whereRecD = whereRecD & Rect(0,0,image.cols,image.rows);
----
<1> Definição da região de destino
<2> Ajuste de dimensionalidade

.Esquema de localização das regiões após a troca
image::/image/regioestrocadas.png[]

Com auxílio da função _copyTo()_, copia-se o conteúdo das quatro _roi_ para a imagem de destino nas posições especificadas

.Realizando a troca das diagonais
[source,cpp]
----
	roiA.copyTo(newImage(whereRecA));
	roiB.copyTo(newImage(whereRecB));
	roiC.copyTo(newImage(whereRecC));
	roiD.copyTo(newImage(whereRecD));
----

Com a execução do programa link:/source_codes/trocaregioes.cpp[trocaregioes.cpp] temos a seguinte saída

.Imagem utilizada na execução do programa
image::/image/biel.png[]

.Image gerada após a execução do programa
image::/image/saidaRegioes.png[]

== Contando objetos de uma imagem

O objetivo deste exercício é identificar, em uma imagem passada como entrada, a quantidade de objetos nela presentes. Para tal, desenvolveu-se um algoritmo de rotulação que utilizará o algoritmo _floodfill(ou seedfill)_. Neste código, trabalharemos com imagens binárias em escala de cinza, isto é, imagens que possuam apenas dois valores possíveis: 0 ou 255, onde o valor _"0"_ representa a ausência de cor e 255 representa a cor do objeto.

A rotulação é um processo onde, para cada conglomerado de pixels,com características em comum, encontrado na imagem analisada, será atribuído um valor em comum.

O processo de execução do algoritmo _floodfill_ tem como premissa um dado ponto inicial(semente) e que, a partir dele, sairá percorrendo os 4-vizinhos ou 8-zisinhos deste pixel, procurando por outros que possuam característica semelhante a da semente. A definição do modo de busca de vizinhança é definido no início do algoritmo e a imagem abaixo ilustra os métodos de busca

.Métodos de busca do _floodfill_
image::/image/vizinhos.png[]

A semente é criada como um objeto da classe *_CvPoint_* 

[source,cpp]
----
CvPoint p;
----

que possui duas dimensões, representando as coordenadas x e y da semente. Como deseja-se percorrer toda a imagem, definimos as coordenadas como (0,0) e definimos variáveis para guardar as dimenões da matriz.

.Definindo a coordenada inicial da semente
[source,cpp]
----
  p.x=0;
  p.y=0;
----

[source,cpp]
----
  width=image.size().width;
  height=image.size().height;
----

A imagem abaixo será utilizada para execução do programa, de forma que com ela temos alguns desafios, além de apenas contar os objetos.

.Imagem a ser analizada
image::/image/bolhas.png[]

O algoritmo deve ser capaz, além de contar a quantidade de objetos, determinar quantos deles possuem buracos e quantos não os possuem. Isso nos leva a ter um cuidado com os objetos que tocam as bordas da imagem, pois não se sabe se estes possuem ou não buracos em sua totalidade.Sendo assim, o algoritmo deve excluí-las do processo antes de começar a procurar por objetos.

.Remoção dos objetos nas bordas superior e inferior
[source,cpp]
----
  nobjectsborder=0; // <1>
	for (int i=0;i<height;i=i+height-1){ // <2>
		for(int j=0;j<width;j++){ //<3>
			if (image.at<uchar>(i,j) == 255){ // <4>
				nobjectsborder++;
				p.x=j;
				p.y=i;
				floodFill(image,p,0); // <5>
			}
		}	
	}
----
<1> Contador de objetos presentes nas bordas
<2> Laço de duas iterações para varrer a borda superior e inferior
<3> Laço para varrer horizontalmente as colunas da matriz _image_
<4> Verificação do valor do pixel
<5> Chamada da função _floodfill_ 

.Remoção dos objetos nas bordas laterais
[source,cpp]
----
	for (int i=0;i<height;i++){
		for(int j=0;j<width;j=j + width -1){
			if (image.at<uchar>(i,j) == 255){
				nobjectsborder++;
				p.x=j;
				p.y=i;
				floodFill(image,p,0);
			}
		}	
	}
----

A função _floodfill_ recebe como parâmetros,respectivamente, a matriz de pixels da imagem de entrada(_image_), a semente(_p_) e o valor a ser atribuído aos píxels com características comuns ao procurado. No caso deste exemplo, atribui-se o valor _"0"_ para que sejam preenchidos com a cor do fundo da imagem.

O resultado desta funcionalidade pode ser observado com a execução do arquivo link:/source_codes/removeObjBorda.cpp[removeObjBorda.cpp]

.Imagem de entrada após a remoção dos objetos das bordas
image::/image/labeling.png[]

Agora podemos voltar a lidar com o problema principal de identificar a quantidade de objetos com e sem buracos. Mas como descobrir se um objeto tem ou não buraco se o algoritmo _floodfill_ procura por pixels de características semelhantes e um buraco é a ausência da cor enquanto o objeto é o valor máximo que o pixel pode assumir?
Para que isso seja possível, deve-se alterar a cor do fundo da imagem, utilizando o algoritmo _floodfill_,pois assim ele irá "pintar" apenas a região externa aos objetos e com isso, apenas o interior de objetos com bolhas possuirão valor "0" em seus pixels. Essa tarefa pode ser executada com o trecho de código abaixo.

[source,cpp]
----
	p.x=0;
	p.y=0;
	floodFill(image,p,175); // <1>
---- 
<1> Atribuindo o valor "175" como nova cor de fundo

O resultado pode ser observado com a execução do arquivo link:/source_codes/trocafundo.cpp[trocafundo.cpp]

.Imagem de entrada após alterar o fundo
image::/image/trocafundo.png[]

Com isso, basta executar o algoritmo novamente buscando por pixels com valor "0" e contá-los para termos ciência da quantidade dos que possuem buracos.

.Buscando pelos buracos dos objetos
[source,cpp]
----
nobjectsholes=0;
  for(int i=0; i<height; i++){
    for(int j=0; j<width; j++){
      if(image.at<uchar>(i,j) == 0){
		// achou um objeto
				nobjectsholes++;
				p.x=j;
				p.y=i;
				floodFill(image,p,100);
	  	}
		}
  }	
----

Agora é trivial descobrir a quantidade de objetos sem buraco, basta realizar uma busca por pixels com valor "255", isso contará inclusive os que possuem buracos, e em seguida fazer uma subtração entre os valores dos contadores.

.Contando todos os objetos
[source,cpp]
----
  nobjects=0;
  for(int i=0; i<height; i++){
    for(int j=0; j<width; j++){
      if(image.at<uchar>(i,j) == 255){
		// achou um objeto
				nobjects++;
				p.x=j;
				p.y=i;
				floodFill(image,p,nobjects); // <1>
	  	}
		}
  }

	std::cout<<"com buracos="<<nobjectsholes<<"\nSem buracos="<<(nobjects - nobjectsholes)<<"\n";
  imshow("image", image);
----
<1> Aplicando o processo de rotulação, de forma que cada objeto terá um rótulo

A execução do algoritmo link:/source_codes/labeling2.cpp[labeling2.cpp] tem como resultado de saída

.Saída do programa labeling2.cpp
image::/image/labeling2saida.png[]


== Manipulação de Histogramas

O histograma é uma ferramenta estatística na qual, basicamente, realiza a contagem de cada amostra presente em uma dada população. No contexto de Processamento Digital de Imagens, o histograma conta a ocorrência de cada uma das variações dos valores presentes em cada pixel da imagem desejada.

Considerando uma imagem em tons de cinza, em que cada pixel é armazenado em uma variável do tipo _unsigned char_ de _8 bits_, onde cada pixel pode possuir valores entre 0 e 255, o histograma desta imagem pode ser visto como mostra a imagem abaixo.

.Exemplo de Histograma de uma imagem
image::/image/exemplo_hist.png[]

=== Equalização

O processo de equalização depende da obtenção do histograma da imagem, pois tal processo funciona da seguinte maneira: Dado o histograma de uma imagem, normaliza-se o valor obtido para cada um do valor dos pixels de forma a contemplar toda a faixa a qual os pixels poderiam possuir.
Por exemplo, caso o histograma de uma imagem seja como a a imagem abaixo

.Exemplo de histograma
image::/image/imghist.png[]

Temos que o valor 45 aparece 10 vezes, 70 aparece 15 vezes, 80 aparece 8 vezes e 95 aparece 5 vezes. No total a imagem possui 38 pixels. O processo de normalização ocorre da seguinte forma

stem:[\frac{45}{38}\\*10 + \frac{70}{38}\\*25 + \frac{80}{38}\\*33 + \frac{95}{38}\\*38 ]

